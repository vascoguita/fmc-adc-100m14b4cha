\input texinfo    @c -*-texinfo-*-
%
% fmc-adc-driver.in - main file for the documentation
%
%%%%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month August 2012
@set release 0.8
@set tagname fine-delay-sw-v1.1

@finalout

@titlepage
@title FMC ADC User's Manual
@subtitle @value{update-month} -- Release @value{release}
@subtitle FMC ADC 100M 14 b 4ch hardware and software manual
@author CERN BE-CO-HT / Federico Vaga
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This is the user manual for the @i{FMC ADC 100M 14b 4cha}
board developed on the @b{Open Hardware Repository}
@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha}}.


@menu
            
@end menu

@c ##########################################################################
@node Repositories and Releases
@chapter Repositories and Releases
This project is hosted on the Open Hardware repository at the
following link:

@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw}


Here a list of the resources that you can find on the project page.
@table @code 
 @item Document 
  @footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/documents}} contains the @t{.pdf} documentation for every official release.

@item File
 @footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/files}} contains the @t{.tar.gz} file for every official release including the @t{.git} tree.

@item Repository
 @footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/repository}} contains the git repository of the project @uref{git://ohwr.org/fmc-projects/fmc-adc-100m14b4cha/fmc-adc-100m14b4cha-sw.git}.
@end table

@c ##########################################################################
@node Driver Features
@chapter Driver Features
This driver is based on the @i{ZIO} framework and the @i{spec-sw}
driver. It supports initial setup of the board, it allows user to
manually configure the board, to start and stop acquisitions, to force
trigger and read latest time-stamps.

@c ##########################################################################
@node Installation
@chapter Installation
This driver depends on two other driver, as well as the Linux kernel.
Also, it must talk to a specific FPGA binary file running in the
carrier card.

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies


@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instruction in the documentation of @i{spec-sw}. To summarize,
you'll need to place the @t{.bin} file in @file{/lib/firmware/fmc}.
The default name of the binary file is @t{fmc-adc.bin} and you
can find the copy of the last tested binary within the source code of
this driver. Anyway, you are free to use a different binary for the your
ADC and you can load it by specifying the module parameter @t{file}.

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The Kernel version for the development was the 3.4, but this driver
is also available for kernel 2.6.32 and 2.6.24.

The driver is base on the ZIO framework available on the OpenHardware
Repository@footnote{@uref{http://www.ohwr.org/projects/zio}}.

@c ==========================================================================
@node Software Installation
@section Software Installation
First of all, please note that you need to define the following
environment variables to be able to compile this driver. All of them
are assumed to be already set when running the commands shown.

@table @code
@item LINUX
	The top-level directory of the Linux kernel you are compiling
        against. This document assumes it is already set.

@item ZIO
	The top-level directory of the ZIO repository checkout.

@item SPEC_SW
	The top-level directory of the @i{spec-sw} repository checkout.

@end table


@c ==========================================================================
@node Module Parameters
@section Module Parameters
The driver accepts a few load-time parameters for configuration. You
can pass them to insmod directly, or write them in @file{/etc/modules.conf}
or the proper file in @file{/etc/modutils/} .


The following parameters are used:
@table @code
 @item file=
  The binary file to use to reprogram the FPGA. The default value for this parameter is @t{fmc/fmc-adc-bin} as seen in @ref{Gateware Installation}
 @item enable_test_data=1
  This is for testing purpose. This option enable the testing data, so the ADC doesn't store samples, but fill the memory with sequential number.
 @item enable_calibration=1
  You should you this if you want to calibrate you ADC. This parameter enable the calibration Volt reference of channels.
@end table

@c ##########################################################################
@node Source Code Conventions
@chapter Source Code Conventions
This is a random list of conventions used in this package

@itemize @bullet
 @item All the internal symbols used in the whole driver begin with the prefix @t{fa_}. The prefix mean: @i{Fmc Adc}.
 @item All internal symbols in the zio driver begin with @t{zfad_}. The prefix mean: @i{Zio Fmc Adc Driver}.

 @item All internal symbols in the zio trigger begin with @t{zfat_}. The prefix mean: @i{Zio Fmc Adc Trigger}.

@end itemize

@c ##########################################################################
@node Device Configuration
@chapter Device Configuration

@c ==========================================================================
@node The ZIO Device Structure
@section The ZIO Device Structure

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation@footnote{@uref{http://www.ohwr.org/projects/zio/documents}}.


The device has 1 cset with 4+1 channels. Channels from 0 to 3
represent che physical channels 1 to 4. The 5th channel
@i{chani} represent a virtual channel created automatically by the
ZIO framework; this channel represent the interleave acquisition on
the cset.

@float
@center @image{img/fmc-adc-hierarchy, 7cm,,FMC ADC ZIO hierarchy, pdf}
@end float

The overall device (@i{fmc-adc}) has not any particular capabilities because
the may feature are handled by the internal trigger.

The ADC registers can be accessed in the proper @i{sysfs} directory. For a
card in slot 0 of bus 1 (like shown above), the directory is 
@i{/sys/bus/zio/devices/fmc-adc-0100}.

There are not any device-wide attribute, so in the device directory there
are only the default attributes.

@smallexample
corinno-test:~# ls -Ff /sys/bus/zio/devices/fmc-adc-0100/
./  ../  name  cset0/  power/  driver@  enable  subsystem@  uevent 
@end smallexample

@c ==========================================================================
@node The Channel Set
@section The Channel Set

The ADC has 1 Channel Set named @file{cset0}. It has attributes to handle the
ADC state machine, the acquisition and the time stamp.

@smallexample
corinno-test:~# ls -Ff /sys/bus/zio/devices/fmc-adc-0100/
./  ../  name  cset0/  power/  driver@  enable  subsystem@  uevent
corinno-test:~# ls -Ff /sys/bus/zio/devices/fmc-adc-0100/cset0/            
./      chan3/           rst-ch-offset     tstamp-acq-end-s  tstamp-acq-str-s   
../     chani/           enable            tstamp-acq-end-t  tstamp-acq-str-t   
name    power/           sample-decimation tstamp-acq-stp-b  uevent             
chan0/  fsm-command      fsm-state         tstamp-acq-stp-s  current_buffer     
chan1/  current_trigger  trigger/          tstamp-acq-stp-t                     
chan2/  resolution-bits  tstamp-acq-end-b  tstamp-acq-str-b  
@end smallexample

The @b{resolution-bits} attribute is read-only and it returns the
number of bits of the ADC:

@smallexample
corinno-test:~# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/resolution-bits
14
@end smallexample

The @b{rst-ch-offset} attribute is write-only. When you write on it, the
driver reset the offset of all channels. 

@smallexample
corinno-test:~# echo 0 > /sys/bus/zio/devices/fmc-adc-0100/cset0/rst-ch-offset
@end smallexample

@c --------------------------------------------------------------------------
@node Sample Decimation
@subsection Sample Decimation

The ADC always acquire ad 100MSamples/s and this value cannot be changed. If
you need less samples you can use the @i{sample-decimation} attribute.

The @b{sample-decimation} attribute is read/write. It configures the number
of sample to drop. You can use value between 1 and 65535.

@smallexample
corinno-test:~# echo 4 > /sys/bus/zio/devices/fmc-adc-0100/cset0/sample-decimation
@end smallexample

The value to write on decimation mean the number of sample to acquire for
each valide samples, for example:

@smallexample
o -> valid sample 
x -> dropped sample

decimation = 1
oooooooooooooooooooo
decimation = 2
oxoxoxoxoxoxoxoxoxox
decimation = 3
oxxoxxoxxoxxoxxoxxox
decimation = 4
oxxxoxxxoxxxoxxxoxxx
decimation = 5
oxxxxoxxxxoxxxxoxxxx
[...]
@end smallexample

@c ---------------------------------------------------------------------------
@node The State Machine
@subsection The State Machine

The acquisition steps are implemented with a @b{state machine}. The driver
exports to the user-space two attributes to handle it: @i{fsm-state} and
@i{fsm-command}.

The @b{fsm-state} attribute is read-only and it returns the code of the
current state of the state machine. In the following example, the state
machine is in the status @i{idle}

@smallexample
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/fsm-state
1
@end smallexample

The @b{fsm-command} attribute is write-only. It is used to write a command
for the state machine. The command available are @i{start} and @i{stop}. The
correspondent values for these commands are, respectively, 1 and 2.


The @i{start} command is used to start the state machine, so to start an
acquisition. You cannot acquire if you don't start the state machine. To
start the state machine you can use the following command:

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/fsm-command
@end smallexample

If the state machine started, the green LED @i{ACQ} on the front panel of the
ADC turns on. If you want to abort the current acquisition you must send the
@i{stop} command to the state machine.

@smallexample
# echo 2 > /sys/bus/zio/devices/fmc-adc-0100/cset0/fsm-command
@end smallexample

When the state machine is stopped, the @i{ACQ} LED turns off. When you send
a @i{stop} command, the driver flush the memory, so all samples acquired are
lost.


Doing the @i{start} command when the state machine is already started do a
restart of the state machine and it flush the memory. This is the same
of following sequence of commands @i{start},@i{stop} and @i{start}.


To acquire data you must start the state machine, if you do not start the
state machine, you cannot acquire data. When an acquisition is completed the
state machine automatically send a @i{stop} command, so you must start the
state machine again for the next acquisition. An acquisition is considered
completed when all stamples, from all shots, are acquired.


The ADC mark with a timestamp all these events: state machine start, state
machine stop and acquisition end. The device split each timestamp in 3
attributes named: second (s), ticks (t) and bins (b). For example, to read
the entire timestamp of the state machin start event you should do:

@smallexample
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/tstamp-acq-str-s
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/tstamp-acq-str-t
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/tstamp-acq-str-b
@end smallexample

Seconds represents the number of second since the epoch; ticks is the
number of clocks at 125Mhz, the value is between 0 and 125000000 and it
increments seconds when it overflow. At the moment, the bins register is
unused.

@c ==========================================================================
@node The Channels
@section The Channels

The ADC has 4 input channels. Each channel has two configurable attribute:
@i{offset} and @i{vref-src}.

The @b{offset} attribute is read/write. It allows to configure the offset of
the signal on the channel. When you write a value to this attribute, the driver
apply your value to a DAC which apply an offset to the input signal.

@smallexample
# echo 50 > /sys/bus/zio/devices/fmc-adc-0100/cset0/chan2/offset
@end smallexample

The @b{vref-src} attribute is read/write. It allow you to change the Volt
reference of the ADC; the attribute accepts only 4 value: @i{0} (open range),
@i{35} ([-100mV; +100mV), @i{17} ([-1V; +1V]), @i{69} ([-10V; +10V]). You
can active some extra reference with the module parameter
@i{enable_calibration}, then you can use the calibration reference. You
should use this option only if you must configure your calibration value.

@smallexample
# echo 17 > /sys/bus/zio/devices/fmc-adc-0100/cset0/chan2/vref-src
@end smallexample



@c ==========================================================================
@node The Trigger
@section The Trigger

The ADC has its own @i{zio_trigger_type} and it can not work with any other
ZIO's trigger. The ADC trigger is named @b{fmc-adc-trg}. We advise you
against replacing the trigger with another one. The sysfs directory of this
trigger is the following:

@smallexample
@end smallexample

On the ADC there are two kind of trigger: hardware and software.

@c ---------------------------------------------------------------------------
@node Hardware Trigger
@subsection Hardware Trigger

The @b{hardware trigger} is moved by the hardware, depending on the status of
the input signals (@i{internal trigger}), or on impulse from an external
source (@i{external trigger}).

The ZIO's default attribute @b{enable} is directly connected to the enable
of the hardware trigger on device. So, if you write 1 you enable the hardware
trigger, if you write 0 you disable the hardware trigger.

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/trigger/enable
@end smallexample

The attribute @b{external} can be used to select if you need the internal
trigger or the external one. You must write 1 to select the external trigger,
0 to select the internal trigger.

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/trigger/external
@end smallexample

With the attribute @b{polarity} you can configure if the trigger fire on a
positive edge/slope or on a negative edge/slope. To configure positive
edge/slope you must write 0 on this attribute, otherwise 1 for a negative
edge/slope.

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/trigger/polarity
@end smallexample
 

@c ---------------------------------------------------------------------------
@node Internal Trigger
@subsubsection Internal Trigger

The @b{internal trigger} is an @i{hardware trigger} and its fire depend on the
the input signal. 
You can select which of the four channels is the trigger source of the
signal and then configure a threshold. When the signal goes above/under the
threshold, the trigger fire.

To choose a channel as source of trigger you must use the @b{int-channel}
attribute. You can select one of the input channel by writing its index
number on the attribute [0; 3]

The attribute @b{int-threshold} is read/write and can be used to select
the signal threshold.

@c ---------------------------------------------------------------------------
@node External Trigger
@subsubsection External Trigger

The @b{external trigger} is an @i{hardware trigger} and its fire depend on
an external source of impulse. When the pulse arrive, the trigger fires.

@c ---------------------------------------------------------------------------
@node Software Trigger
@subsection Software Trigger

The software trigger should be used only for debug purpose. You can enable
it by writing 1 on the attribute @b{sw-trg-enable}, 0 to disable it. To make
this trigger fire, you must write in the write-only attribute @b{sw-trg-fire}.

@c ==========================================================================
@node The Buffer
@section The Buffer

The ADC can use both @i{zio-buf-kmalloc} and @i{zio-buf-vmalloc} to store
the samples. It is not necesarry to develop a dedicated buffer for this device.

@c ==========================================================================
@node Attributes
@section Attributes

Here the list of all the ZIO's attributes within this driver.
     @multitable @columnfractions .10 .25 .2 .1 .2 .30
     @headitem Target @tab Name @tab Permission @tab Default @tab Accepted @tab Comment 
     @c Cset
     @item Cset @tab @code{enable} @tab rw @tab 1 @tab [0;1]
     @item Cset @tab @code{resolution-bits} @tab ro @tab 14 @tab -
     @item Cset @tab @code{fsm-command} @tab wo @tab 2 @tab [1;2]
     @item Cset @tab @code{fsm-state} @tab r0 @tab - @tab -
     @item Cset @tab @code{sample-decimation} @tab rw @tab 1 @tab [1;655353]
     @item Cset @tab @code{rst-ch-offset} @tab wo @tab 0 @tab any
     @item Cset @tab @code{tstamp-acq-str-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-str-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-str-b} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-b} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-b} @tab ro @tab - @tab -
     @c Channel
     @item Cset @tab @code{offset} @tab rw @tab 0 @tab [0; 65535] @tab [-Vref; +Vref]
     @item Cset @tab @code{vref-src} @tab rw @tab 17 @tab [0, 17, 35, 69]
     @c Trigger
     @item Trigger @tab @code{enable} @tab rw @tab 1 @tab [0;1]
     @item Tigger @tab @code{external} @tab rw @tab 1 @tab [0;1]
     @item Tigger @tab @code{polarity} @tab rw @tab 0 @tab [0;1]
     @item Tigger @tab @code{int-channel} @tab rw @tab 0 @tab [0;3]
     @item Tigger @tab @code{int-threshold} @tab rw @tab 0 @tab [0;65535] @tab Complement 2
     @item Tigger @tab @code{sw-trg-enable} @tab rw @tab 0 @tab [0;1]
     @item Tigger @tab @code{sw-trg-fire} @tab wo @tab 0 @tab any
     @item Cset @tab @code{tstamp-trg-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-trg-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-trg-b} @tab ro @tab - @tab -
     @end multitable

@c ==========================================================================
@node Reading Data with Char Devices
@chapter Reading Data with Char Devices
To read data from user-space you can use the ZIO char device interface
which export 2 char device for each channel (as documented in
ZIO documentation). The ADC acquire only interleaved samples, so the char
device interface creates only the char device for the interleaved acquisition.

@smallexample
# ls -l /dev/zio/
total 0
crw------- 1 root root 250, 8 Aug 23 22:21 fmc-adc-0100-0-i-ctrl
crw------- 1 root root 250, 9 Aug 23 22:21 fmc-adc-0100-0-i-data
@end smallexample

The actual pathnames depend on the version of @i{udev}, and the support
library tries both names (the new one shown above, and the older one,
without a @code{zio} subdirectory).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.


If more than one board is probed for, you'll have two or more similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0100}. The @i{dev_id} field is built using the PCI bus
and the @i{devfn} octet; the example above refers to slot 0 of bus 1.


The ADC doesn't allow to read data from a specific channel; the ADC
allow the driver to read only an interleaved block of samples.
Neither the ZIO core nor this driver split interleaved data into
4 different buffer; so, also the driver will return to user-space a
block of interleaved samples. To read this interleaved block you
can read directly the interleaved data char device @i{fmc-adc-0100-0-i-data}

@smallexample
# hexdump -n 8 -e '"" 1/2 "%x\n"' /dev/zio/fmc-adc-0100-0-i-data
fffc
e474
8034
8084
@end smallexample


The graphical representation of the interleaving is in the following
figure.


@float
@center @image{img/interleaved, 7cm,,ADC interleaved data,pdf}
@end float

@c ==========================================================================
@node Tools
@chapter Tools

The FMC ADC driver is provided with three tools: @i{fau-trg-config}, @i{fau-acq-time} and @i{parport-burst}.

@c ==========================================================================
@node Trigger Configuration
@section Trigger Configuration

You can use the tool @b{fau-trg-config} to configure the FMC ADC trigger. The
tools has many command line parameter that you can use to configure every
register exporter by the driver. You can read a simple description of the
program from the program's help.

@smallexample
$ ./fau-trg-config --help

fau-trg-config [OPTIONS] <DEVICE>

  <DEVICE>: ZIO name of the device to use
  --pre|-p <value>: number of pre samples
  --post|-P <value>: number of pre samples
  --re-enable|-r <value>: number of trigger shots
  --delay|-d <value>: set the ticks delay of the trigger
  --threshold|-t <value>: set internal trigger threshold
  --channel|-c <value>: select the internal channel as trigger
  --external: set to external trigger. The default is the internal trigger.
  --negative-edge: set internal trigger polarity to negative edge. The default
                    is positive edge.
  --enable-sw-trg: enable the software trigger. By default is disabled.
  --disable-hw-trg: disable the hardware trigger. By default is enabled
  --force: force all attribute to the program default
  --help|-h: show this help

NOTE: The software trigger works only if also hardware trigger is enabled
@end smallexample

The tool gets the configuration values from the user and it writes these values
in the correspondent sysfs attributes exported by the driver. For example, if
you want to configure the trigger to fire with an external pulse and to acquire
3 shots of 10 pre-samples and 100 post-samples, you must write:

@smallexample
# ./fau-trg-config --external --pre 10 --post 100 --re-enable 2 fmc-adc-0100
@end smallexample

The trigger is always active the first time, then you configure it to auto
re-enable other 2 times; so you acquire 3 shots.

@c ==========================================================================
@node Acquisition Time
@section Acquisition Time

You can use the tool @b{fau-acq-time} to get the time spent during the
acquisition.  You can read a simple description of the
program from the program's help.

@smallexample
# ./fau-acq-time 

fau-acq-time [OPTIONS] <DEVICE>

  <DEVICE>: ZIO name of the device to use
  --last|-l : time between the last trigger and the acquisition end
  --full|-f : time between the acquisition start and the acquisition end
  --help|-h : show this help

@end smallexample

The program can return two kind of acquisition time. The first acquisition
time (@code{--last}) is the time between the last trigger event and the
acquisition end event, so the time spent during the last shot. The second
acquisition time (@code{--full}) is the time between the acquisition start
event and the acquisition end event, so the whole time spent to wait all
trigger fires (multi shots) and the time to acquire all samples.

@c ==========================================================================
@node Parallel Port Burst
@section Parallel Port Burst
If you have a Parallel Port you can use it to generate bursts of pulses
with a software program. This is usefull to test external trigger; you can
connect the parallel port to the external trigger of the FMC ADC and
generate your trigger fire from an external source.

The program @b{parport-burst}@footnote{This tool is also part
of the @i{fine-delay} tools.}, part of this package, generates a
burst according to three command line parameters: the I/O port of
the data byte of the parallel port, the repeat count and the duration
of each period. This example makes 1000 pulses of 100 usec each,
using the physical address of my parallel port (if yours is part
of the motherboard, the address is @code{378}):

@example
   ./parport-burst dd00 1000 100
@end example

@bye


