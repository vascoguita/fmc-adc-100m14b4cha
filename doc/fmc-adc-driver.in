\input texinfo    @c -*-texinfo-*-
%
% fmc-adc-driver.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fmc-adc-driver.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fmc-adc-driver.info
@settitle fmc-adc-driver
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month November 2012
@set release 1.0
@set tagname fmc-adc-sw1.0

@finalout

@titlepage
@title FMC ADC User's Manual
@subtitle @value{update-month} -- Release @value{release}
@subtitle FMC ADC 100M 14 b 4ch software manual
@author CERN BE-CO-HT / Federico Vaga / Alessandro Rubini
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This is the user manual of the driver for the @i{FMC ADC 100M 14b 4cha}
board developed on the @b{Open Hardware Repository}
@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha}}.


@menu

@end menu

@c ##########################################################################
@node Repositories and Releases
@chapter Repositories and Releases
This project is hosted on the Open Hardware repository at the
following link:

@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw}


Here a list of resources that you can find on the project page.
@table @code

@item Document@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/documents}}
contains the @t{.pdf} documentation for every official release.

@item File@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/files}}
contains the @t{.tar.gz} file for every official release including the @t{.git} tree.

@item Repository@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/repository}} contains the git repository of the project

@end table

On the repository the official releases have a tag named
@code{fmc-adc-sw-v#maj.#min} where @i{#maj} represent the major release
version of the driver and @i{#min} the minor one (e.g @code{fmc-adc-sw-v1.2}).

@b{Note:} If you got this from the repository (as opposed to a named
@i{tar.gz} or @i{pdf} file) it may happen that you are looking at a later commit
than the release this manual claims to document.
It is a fact of life that developers forget to re-read and fix documentation
while updating the code. In that case, please run ``@code{git describe HEAD}''
to ensure where you are.

@c ##########################################################################
@node Driver Features
@chapter Driver Features
This driver is based on the @i{ZIO} framework and the @i{fmc-bus}. It supports
initial setup of the board; it allows users to manually configure the board,
to start and stop acquisitions, to force trigger, to read latest time-stamps
and to read acquired samples.

@c ##########################################################################
@node Installation
@chapter Installation
This driver depends on two other driver, as well as the Linux kernel.
Also, it must talk to a specific FPGA binary file running in the
carrier card.

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies

This driver has been developed from the FPGA binary included in the package,
as a @t{.bin} file in the @file{binaries/} subdir.

The driver repository always include the last binary version used during
development. It can happen that the binary within this package become out
of dated when new binary is released.

@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instruction in the documentation of @i{fmc-bus}.

To summarize, you'll need to place the @t{.bin} file in @file{/lib/firmware/}.
By default, the driver looks for @t{fmc/adc-100m14b.bin}@footnote{the full
path will be @file{/lib/firmware/fmc/adc-100m14b.bin}}. You
can find the copy of the last tested binary within the driver repository.
Anyway, you are free to use a different binary for your
ADC and you can load it by specifying the module parameter @t{file}.

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The kernel versions used during development is 3.4.  Everything used here is
known to at least compile with version 2.6.32,

The driver is base on the ZIO framework available on the OpenHardware
Repository@footnote{@uref{http://www.ohwr.org/projects/zio}}. The version
being used during development is a development version and tested on Linux
kernel 3.4, then back-ported to Linux kernel version 2.6.32 and 2.6.24.

The driver is also based on the @i{fmc-bus} available on the OpenHardware
Repository@footnote{@uref{http://www.ohwr.org/projects/fmc-bus}}. This bus
allows to handle FMC devices connected to a SPEC or a SVEC board (or whatever
else).

Both packages are currently checked out as @i{git submodules} of this package,
and each of them is retrieved at the right version to be compatible with this
driver.  This means you may just ignore software dependencies and everything
should work.

@c ==========================================================================
@node Software Installation
@section Software Installation

To install this software package, you need to tell it where your
kernel sources live, so the package can pick the right header files.
You need to set only one environment variable:

@table @code
@item LINUX

	The top-level directory of the Linux kernel you are compiling
        against. If not set, the default may work if you compile in the same
        host where you expect to run the driver.

@end table

Most likely, this is all you need to set. After this, you can
run:

@example
    make
    sudo make install LINUX=$LINUX
@end example

In addition to the normal installation procedure for @code{fmc-adc-100m14b.ko}
you'll see the following message:

@example
    WARNING: Consider "make prereq_install"
@end example

The @i{prerequisite} packages are @i{zio} and @i{fmc-bus};
unless you already installed your own preferred version, you are
expected to install the version this packages suggests. This step
can be performed by:

@example
    make
    sudo make prereq_install LINUX=$LINUX
@end example

The step is not performed by default to avoid overwriting some
other versions of the drivers. After @code{make prereq_install},
the warning message won't be repeated any more if you change this
driver and @code{make install} again.

@c FIXME how to load the driver, look at fine-delay manual

In order to compile @i{fmc-adc} against a specific version of one
of the related packages, you can use one or more of the following
environment variables:


@table @code
@item ZIO
@item FMC-BUS
	The top-level directory of the @i{fmc-bus}/@i{zio} repository checkout.

@end table

@c ==========================================================================
@node Module Parameters
@section Module Parameters
The driver accepts a few load-time parameters for configuration. You
can pass them to insmod directly, or write them in @file{/etc/modules.conf}
or the proper file in @file{/etc/modutils/} .


The following parameters are used:
@table @code
 @item file=/path/to/binary.bin
  The binary file to use to reprogram the FPGA. The default value for this
  parameter is @t{fmc/adc-100m14b.bin} as seen in @ref{Gateware Installation}.
  The path to binary is the relative path from @file{/lib/firmware}
 @item enable_test_data=1
  This is for testing purpose. This option enables the testing data, so the ADC
  doesn't store samples, but fill the memory with sequential numbers.
@end table

@c ##########################################################################
@node About Source Code
@chapter About Source Code

@c ==========================================================================
@node Source Code Organization
@section Source Code Organization

The source code for the ADC driver and tools is splitted in three directory:
@itemize @bullet
 @item @file{kernel/}: this directory contains all source files to build the
       driver module. Each file represents a feature of the complete driver.
 @item @file{lib/}: this directory contains all source files to build the
       userspace library.
 @item @file{tools/}: this directory includes standalone tools that access the
       ADC driver directly. Their name begins with @file{fau-} that mean:
       @i{Fmc Adc User}. There is also a non ZIO tool to generate pulses on the
       parallel port, so it has a different name pattern.
 @item @file{libtools/}: this directory contains tools which use the fmcadc
       library. Their name begins with @file{fald-} that mean:
       @i{Fmc Adc Library Dependent}.
@end itemize

@c ==========================================================================
@node Source Code Conventions
@section Source Code Conventions

This is a random list of conventions used in this package

@itemize @bullet
 @item All the internal symbols used in the whole driver begin with the prefix
       @t{fa_}. The prefix mean: @i{Fmc Adc}.
 @item All internal symbols in the zio driver begin with @t{zfad_}. The prefix
       mean: @i{Zio Fmc Adc Driver}.
 @item All internal symbols in the zio trigger begin with @t{zfat_}. The prefix
       mean: @i{Zio Fmc Adc Trigger}.
@end itemize

@c ==========================================================================
@node Source Code Overview
@section Source Code Overview

To better understand the source code, please see the state machine image and
the call graph image.

Here the representation of the ADC state machine, and how it interact with the
driver.

@float
@center @image{img/fmc-adc-fsm, 15cm,,FMC ADC State Machine, pdf}
@end float

Here the graphical rapresentation of the functions call in the driver and how
the driver interact with the ZIO framework and the FMC bus. The image is large,
so please get the full scale image from the project website.

@float
@center @image{img/fmc-adc-call, 15cm,,FMC ADC Call Graph, pdf}
@end float

@c ##########################################################################
@node Device Configuration
@chapter Device Configuration

The driver is designed as a ZIO driver that offers 4 input channels. Since
the device store only interleaved data, the ZIO framework will create a
fifth channel which represent the interleaved acquisition.

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation@footnote{@uref{http://www.ohwr.org/projects/zio/documents}}.

@c ==========================================================================
@node The ZIO Device Structure
@section The ZIO Device Structure

The device has 1 cset with 4+1 channels. Channels from 0 to 3
represent che physical channels 1 to 4. The 5th channel
@i{chani} represent a virtual channel created automatically by the
ZIO framework; this channel represent the interleave acquisition on
the cset.

@float
@center @image{img/fmc-adc-hierarchy, 7cm,,FMC ADC ZIO hierarchy, pdf}
@end float

The ADC registers can be accessed in the proper @i{sysfs} directory. For a
card in slot 0 of bus 2 (like shown above), the directory is
@i{/sys/bus/zio/devices/adc-100m14b-0200}.

The overall device (@i{fmc-adc}) has not any particular capabilities because
the main features are handled by @i{cset0} and @i{trigger}. So, there are
not any device-wide attribute, there are only the ZIO's default attributes.

@smallexample
# ls -Ff /sys/bus/zio/devices/adc-100m14b-0200/
./   name     devtype  power/  subsystem@   uevent
../  devname  cset0/   enable  temperature

@end smallexample
@c FIXME: ``driver@'' missing above.

@c FIXME better explaination
@c The @{temperature} attribute is read-only. It returns the temperature of the
@c card in 10^1 Â°C

@c ==========================================================================
@node The Channel Set
@section The Channel Set

The ADC has 1 Channel Set named @file{cset0}. It has attributes to handle the
ADC state machine, the acquisition and the time stamp.

@smallexample

# ls -Ff /sys/bus/zio/devices/adc-100m14b-0200/cset0/
./              chani/             ch0-vref          tstamp-acq-str-t
../             power/             ch1-vref          ch3-vref
name            fsm-command        tstamp-acq-end-b  ch3-offset
ch3-50ohm-term  current_trigger    tstamp-acq-end-s  uevent
devname         resolution-bits    tstamp-acq-end-t  current_buffer
devtype         rst-ch-offset      ch2-vref          ch0-50ohm-term
ch2-offset      enable             tstamp-acq-stp-b  ch1-50ohm-term
chan0/          ch1-offset         tstamp-acq-stp-s  ch0-offset
chan1/          fsm-state          tstamp-acq-stp-t  ch2-50ohm-term
chan2/          trigger/           tstamp-acq-str-b  fsm-auto-start
chan3/          sample-decimation  tstamp-acq-str-s
@end smallexample

The @b{resolution-bits} attribute is read-only and it returns the
number of bits of the ADC:

@smallexample
corinno-test:~# cat /sys/bus/zio/devices/adc-100m14b-0200/cset0/resolution-bits
14
@end smallexample

The @b{rst-ch-offset} attribute is write-only. When you write on it, the
driver reset the offset of all channels.

@smallexample
corinno-test:~# echo 0 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/rst-ch-offset
@end smallexample

@c --------------------------------------------------------------------------
@node Channel Attributes (offset and vref)
@subsection Channel Attributes (offset and vref)

This driver requires interleave feature that ZIO doesn't support ufficially and
it is not complete. To work properly with the proposed interleave feature, the
driver must define some channel's attributes within the channel set. So, the
ADC export offset, volt-reference and termination for each channel in the
channel-set layer:

@smallexample
# ls /sys/bus/zio/devices/adc-100m14b-0200/cset0/ | grep ch.-
ch0-50ohm-term
ch0-offset
ch0-vref
ch1-50ohm-term
ch1-offset
ch1-vref
ch2-50ohm-term
ch2-offset
ch2-vref
ch3-50ohm-term
ch3-offset
ch3-vref
@end smallexample

The @b{*-offset} attribute is read/write. It allows to configure the offset of
the signal on the channel. The value is expressed in millivolts, in
the range [-5000,5000]. When you write a value to this attribute, the driver
apply your value to a DAC which apply an offset to the input signal.

@smallexample
# echo 1000 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/ch0-offset
@end smallexample

The @b{*-vref} attribute is read/write. It allow you to change the Volt
reference of the ADC; the attribute accepts only 4 value: @i{0} (open range),
@i{35} ([-100mV; +100mV), @i{17} ([-1V; +1V]), @i{69} ([-10V; +10V]).

@smallexample
# echo 17 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/ch0-vref
@end smallexample

The @b{*-50ohm-term} attirbute is read/write. It allow to enable (1) or
disable (0) the 50Ohm termination.

@smallexample
# echo 1 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/ch0-50ohm-term
@end smallexample

@c --------------------------------------------------------------------------
@node Sample Decimation
@subsection Sample Decimation

The ADC always acquires at 100MSamples/s and this value cannot be changed. If
you need less samples you can use the @i{sample-decimation} attribute.

The @b{sample-decimation} attribute is read/write. It configures the number
of sample to drop. You can use value between 1 and 65535.

@smallexample
# echo 4 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/sample-decimation
@end smallexample

The value to write on decimation mean the number of sample to acquire for
each valide samples, for example:

@smallexample
o -> valid sample
x -> dropped sample

decimation = 1
oooooooooooooooooooo
decimation = 2
oxoxoxoxoxoxoxoxoxox
decimation = 3
oxxoxxoxxoxxoxxoxxox
decimation = 4
oxxxoxxxoxxxoxxxoxxx
decimation = 5
oxxxxoxxxxoxxxxoxxxx
[...]
@end smallexample

@c ---------------------------------------------------------------------------
@node The State Machine
@subsection The State Machine

The acquisition steps are implemented with a @b{state machine}. The driver
exports to the user-space three attributes to handle it: @i{fsm-state},
@i{fsm-command} and @i{fsm-auto-start}.

The @b{fsm-state} attribute is read-only and it returns the code of the
current state of the state machine. In the following example, the state
machine is in the status @i{idle}

@smallexample
# cat /sys/bus/zio/devices/adc-100m14b-0200/cset0/fsm-state
1
@end smallexample

The @b{fsm-command} attribute is write-only. It is used to write a command
for the state machine. The command available are @i{start} and @i{stop}. The
correspondent values for these commands are, respectively, 1 and 2.


The @i{start} command is used to start the state machine, so to start an
acquisition. You cannot acquire if you don't start the state machine. To
start the state machine you must use the following command:

@smallexample
# echo 1 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/fsm-command
@end smallexample

If the state machine started, the green LED @i{ACQ} on the front panel of the
ADC turns on.

If you want to abort the current acquisition you must send the
@i{stop} command to the state machine.

@smallexample
# echo 2 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/fsm-command
@end smallexample

When the state machine is stopped, the @i{ACQ} LED turns off. When you send
a @i{stop} command, the driver flush the memory, so all samples acquired are
lost.


Doing the @i{start} command when the state machine is already started do a
restart of the state machine and it flush the memory. This is the same
of following sequence of commands: @i{start},@i{stop} and @i{start}.


To acquire data you must start the state machine, if you do not start the
state machine, you cannot acquire data. When an acquisition is completed the
state machine automatically send a @i{stop} command, so you must start the
state machine again for the next acquisition. An acquisition is considered
completed when all stamples, from all shots, are acquired.

The @b{fsm-auto-start} attribute is read/write. It is used to activate the
auto-start acquisition option. We said that when an acquisition is over, the
ADC stops the state machine; if you write 1 in this attribute, the driver sends
a @i{start} command when the acquisition is over. This is useful for something
like a streaming acquisition, because the driver starts the state machine
automatically.


The ADC mark with a timestamp all these events: state machine start, state
machine stop and acquisition end. The device split each timestamp in 3
attributes named: second (s), ticks (t) and bins (b). For example, to read
the entire timestamp of the state machin start event you should do:

@smallexample
# cat /sys/bus/zio/devices/adc-100m14b-0200/cset0/tstamp-acq-str-s
# cat /sys/bus/zio/devices/adc-100m14b-0200/cset0/tstamp-acq-str-t
# cat /sys/bus/zio/devices/adc-100m14b-0200/cset0/tstamp-acq-str-b
@end smallexample

Seconds represents the number of second since the epoch; ticks is the
number of clocks at 125Mhz, the value is between 0 and 125000000 and it
increments seconds when it overflow. At the moment, the bins register is
unused.

@c ==========================================================================
@node The Channels
@section The Channels

The ADC has 4 input channels. Each channel has one attribute with the last
acquired sample @i{current-value}.

@smallexample
# ls -fF /sys/bus/zio/devices/adc-100m14b-0200/cset0/chan0/
./  ../  name  power/  current-value  buffer/  enable  current-control  uevent
@end smallexample
@c FIXME: missing devname, devtype, alarm, address

The @b{current-value} attribute is read only. It returns the last converted
value on the channel.

@smallexample
# cat /sys/bus/zio/devices/adc-100m14b-0200/cset0/chan0/current-value
32860
@end smallexample

@c ==========================================================================
@node The Trigger
@section The Trigger

The ADC has its own @i{zio_trigger_type} and it can not work with any other
ZIO's trigger. The ADC trigger is called @b{fmc-adc-trg}. We advise you
against replacing the trigger with another one. The sysfs directory of this
trigger is the following:

@smallexample
# ls -fF /sys/bus/zio/devices/adc-100m14b-0200/cset0/trigger/
./           external          tstamp-trg-lst-t  sw-trg-enable  pre-samples
../          devtype           delay             enable         sw-trg-fire
name         tstamp-trg-lst-b  power/            nshots         post-samples
int-channel  tstamp-trg-lst-s  polarity          uevent         int-threshold
@end smallexample
@c FIXME: check list above

On the ADC there are two kind of trigger: hardware and software.

@c ---------------------------------------------------------------------------
@node Hardware Trigger
@subsection Hardware Trigger

The @b{hardware trigger} is moved by the hardware, depending on the status of
the input signals (@i{internal trigger}), or on impulse from an external
source (@i{external trigger}).

The ZIO's default attribute @b{enable} is directly connected to the enable
of the hardware trigger on device. So, if you write 1 you enable the hardware
trigger, if you write 0 you disable the hardware trigger.

@smallexample
# echo 1 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/trigger/enable
@end smallexample

The attribute @b{external} can be used to select the @i{internal trigger}
or the @i{external trigger}. You must write 1 to select the external trigger,
0 to select the internal trigger.

@smallexample
# echo 1 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/trigger/external
@end smallexample

With the attribute @b{polarity} you can configure if the trigger fire on a
positive edge/slope or on a negative edge/slope. To configure positive
edge/slope you must write 0 on this attribute, otherwise 1 for a negative
edge/slope.

@smallexample
# echo 1 > /sys/bus/zio/devices/adc-100m14b-0200/cset0/trigger/polarity
@end smallexample


@c ---------------------------------------------------------------------------
@node Internal Trigger
@subsubsection Internal Trigger

The @b{internal trigger} is an @i{hardware trigger} and its fire depend on the
the input signal.
You can select the channel to use as trigger source and then
configure a threshold. When the signal goes above/under@footnote{it depends
on the attribute @i{polarity}} the
threshold, the trigger fire.

To choose a channel as trigger source you must use the @b{int-channel}
attribute. You can select one of the input channel by writing its index
number on the attribute [0; 3]

The attribute @b{int-threshold} is read/write and can be used to select
the signal threshold.

@c ---------------------------------------------------------------------------
@node External Trigger
@subsubsection External Trigger

The @b{external trigger} is an @i{hardware trigger} and its fire depend on
an external source of impulse. When the pulse arrive, the trigger fires.

@c ---------------------------------------------------------------------------
@node Software Trigger
@subsection Software Trigger

The software trigger should be used only for debug purpose. You can enable
it by writing 1 on the attribute @b{sw-trg-enable}, 0 to disable it. To make
this trigger fire, you must write in the write-only attribute @b{sw-trg-fire}.

@c ==========================================================================
@node The Buffer
@section The Buffer

The ADC can use both @i{zio-buf-kmalloc} and @i{zio-buf-vmalloc} to store
the samples. It is not necesarry to develop a dedicated buffer for this device.
By default the driver is configured to use the @i{zio-buf-vmalloc} buffer.


If you want to change the buffer, you can use the @code{current_buffer}
attribute within the @code{cset0} directory. As explained in the ZIO manual,
this is a default attribute of the ZIO framework. It allows the user to
dinamically change the buffer to use. If you want to use the @i{kmalloc}
buffer you must write:

@smallexample
# echo kmalloc > /sys/bus/zio/devices/adc-100m14b-0200/cset0/current_buffer
@end smallexample

To restore the @i{vmalloc} buffer:

@smallexample
# echo vmalloc > /sys/bus/zio/devices/adc-100m14b-0200/cset0/current_buffer
@end smallexample

@c ==========================================================================
@node Attributes
@section Attributes

Here the list of all the ZIO's attributes within this driver. Plese note
that ZIO framework can handle only 32bit unsigned integer.

     @multitable @columnfractions .10 .25 .2 .1 .2 .30
     @headitem Target @tab Name @tab Permission @tab Default @tab Accepted @tab Comment
     @c Cset
     @item Cset @tab @code{enable} @tab rw @tab 1 @tab [0;1]
     @item Cset @tab @code{resolution-bits} @tab ro @tab 14 @tab -
     @item Cset @tab @code{fsm-command} @tab wo @tab 2 @tab [1;2]
     @item Cset @tab @code{fsm-auto-start} @tab rw @tab 0 @tab [0;1]
     @item Cset @tab @code{fsm-state} @tab ro @tab - @tab -
     @item Cset @tab @code{sample-decimation} @tab rw @tab 1 @tab [1;655353]
     @item Cset @tab @code{rst-ch-offset} @tab wo @tab 0 @tab any
     @item Cset @tab @code{tstamp-acq-str-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-str-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-str-b} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-b} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-b} @tab ro @tab - @tab -
     @item Cset @tab @code{chN-offset}@footnote{N from 0 to 3} @tab rw @tab 0 @tab [0; 65535] @tab [-Vref; +Vref]
     @item Cset @tab @code{chN-vref}@footnote{N from 0 to 3} @tab rw @tab 17 @tab [0, 17, 35, 69]
     @c Channel
     @item Channel @tab @code{current-value} @tab ro @tab - @tab -
     @c Trigger
     @item Trigger @tab @code{enable} @tab rw @tab 1 @tab [0;1]
     @item Trigger @tab @code{external} @tab rw @tab 1 @tab [0;1]
     @item Trigger @tab @code{polarity} @tab rw @tab 0 @tab [0;1]
     @item Trigger @tab @code{int-channel} @tab rw @tab 0 @tab [0;3]
     @item Trigger @tab @code{int-threshold} @tab rw @tab 0 @tab [0;65535] @tab [-Vref; +Vref]
     @item Trigger @tab @code{sw-trg-enable} @tab rw @tab 0 @tab [0;1]
     @item Trigger @tab @code{sw-trg-fire} @tab wo @tab 0 @tab any
     @item Trigger @tab @code{tstamp-trg-s} @tab ro @tab - @tab -
     @item Trigger @tab @code{tstamp-trg-t} @tab ro @tab - @tab -
     @item Trigger @tab @code{tstamp-trg-b} @tab ro @tab - @tab -
     @end multitable

@c ==========================================================================
@node Reading Data with Char Devices
@chapter Reading Data with Char Devices
To read data from user-space you can use the ZIO char device interface
which export 2 char device for each channel (as documented in
ZIO documentation). The ADC acquire only interleaved samples, so the char
device interface creates only the char device for the interleaved acquisition.

@smallexample
# ls -l /dev/zio/
total 0
crw------- 1 root root 250, 8 Aug 23 22:21 adc-100m14b-0200-0-i-ctrl
crw------- 1 root root 250, 9 Aug 23 22:21 adc-100m14b-0200-0-i-data
@end smallexample
@c FIXME check permission as shown

The actual pathnames depend on the version of @i{udev}, and the support
library tries both names (the new one shown above, and the older one,
without a @code{zio} subdirectory).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.


If more than one board is probed for, you'll have two or more similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0100}. The @i{dev_id} field is built using the PCI bus
and the @i{devfn} octet; the example above refers to slot 0 of bus 1.


The ADC does not allow to read data from a specific channel; the ADC
allow the driver to read only an interleaved block of samples.
Neither the ZIO core nor this driver split interleaved data into
4 different buffer; so, also the driver will return to user-space a
block of interleaved samples. To read this interleaved block you
can read directly the interleaved data char device @i{adc-100m14b-0200-0-i-data}
using simple program like @i{hexdump}@footnote{man hexdump if you do not
know this program}:

@smallexample
# hexdump -n 8 -e '"" 1/2 "%x\n"' /dev/zio/adc-100m14b-0200-0-i-data
fffc
e474
8034
8084
@end smallexample


The FMC ADC interleave always all channels, you cannot select which channel
acquire. So your acquisitions will have this format:


@float
@center @image{img/interleaved, 7cm,,ADC interleaved data,pdf}
@end float


It is suggested to read the ZIO documentation to understand how to read data
from the ZIO char device interface and the mechanism of control char device
and data char device. You can use the @b{zio-dump} tool from
the ZIO package to acquire data and understand the mechanism behind this
interface.


@c ##########################################################################
@node Tools
@chapter Tools

The FMC ADC driver is provided with three tools: @i{fau-trg-config},
@i{fau-acq-time} and @i{parport-burst}.

@c ==========================================================================
@node Trigger Configuration
@section Trigger Configuration

You can use the tool @b{fau-trg-config} to configure the FMC ADC trigger. The
tools has many command line parameter that you can use to configure every
register exporter by the driver. You can read a simple description of the
program from the program's help.

@smallexample
$ ./fau-trg-config --help

fau-trg-config [OPTIONS] <DEVICE>

  <DEVICE>: ZIO name of the device to use
  --pre|-p <value>: number of pre samples
  --post|-P <value>: number of pre samples
  --re-enable|-r <value>: number of trigger shots
  --delay|-d <value>: set the ticks delay of the trigger
  --threshold|-t <value>: set internal trigger threshold
  --channel|-c <value>: select the internal channel as trigger
  --external: set to external trigger. The default is the internal trigger.
  --negative-edge: set internal trigger polarity to negative edge. The default
                    is positive edge.
  --enable-sw-trg: enable the software trigger. By default is disabled.
  --disable-hw-trg: disable the hardware trigger. By default is enabled
  --force: force all attribute to the program default
  --help|-h: show this help

NOTE: The software trigger works only if also hardware trigger is enabled
@end smallexample

The tool gets the configuration values from the user and it writes these values
in the correspondent sysfs attributes exported by the driver. For example, if
you want to configure the trigger to fire with an external pulse and to acquire
3 shots of 10 pre-samples and 100 post-samples, you must write:

@smallexample
# ./fau-trg-config --external --pre 10 --post 100 --re-enable 2 adc-100m14b-0200
@end smallexample

The trigger is always active the first time, then you configure it to auto
re-enable other 2 times; so you acquire 3 shots.

@c ==========================================================================
@node Acquisition Time
@section Acquisition Time

You can use the tool @b{fau-acq-time} to get the time spent during the
acquisition.  You can read a simple description of the
program from the program's help.

@smallexample
# ./fau-acq-time

fau-acq-time [OPTIONS] <DEVICE>

  <DEVICE>: ZIO name of the device to use
  --last|-l : time between the last trigger and the acquisition end
  --full|-f : time between the acquisition start and the acquisition end
  --help|-h : show this help

@end smallexample

The program can return two kind of acquisition time. The first acquisition
time (@code{--last}) is the time between the last trigger event and the
acquisition end event, so the time spent during the last shot. The second
acquisition time (@code{--full}) is the time between the acquisition start
event and the acquisition end event, so the whole time spent to wait all
trigger fires (multi shots) and the time to acquire all samples.

@c ==========================================================================
@node Parallel Port Burst
@section Parallel Port Burst
If you have a Parallel Port you can use it to generate bursts of pulses
with a software program. This is usefull to test external trigger; you can
connect the parallel port to the external trigger of the FMC ADC and
generate your trigger fire from an external source.

The program @b{parport-burst}@footnote{This tool is also part
of the @i{fine-delay} tools.}, part of this package, generates a
burst according to three command line parameters: the I/O port of
the data byte of the parallel port, the repeat count and the duration
of each period. This example makes 1000 pulses of 100 usec each,
using the physical address of my parallel port (if yours is part
of the motherboard, the address is @code{378}):

@example
   ./parport-burst dd00 1000 100
@end example

@c ##########################################################################
@node The ADC Library
@chapter The ADC Library

To simplify the user-space development you can use the ADC library that you
can find in @file{lib/}. The library design is independent from the driver,
but only the ZIO implementation is available. You can improve this library
by implementing the interface to a different kind of driver.


@c ==========================================================================
@node The ADC Library Design
@section The ADC Library Design

The main idea behind the library implementation is to provide an API suitable
for different kind of driver. To comply this requirement the library is based
on two main compoments: the library routing, the adc operations.


@float
@center @image{img/library, 8cm,, ADC Library overview, pdf}
@end float

The library @i{adc operations} is a structure of functions. An implementation
for a kind of drivers, must implements these operations.

@smallexample
struct fmcadc_op {
    /* Handle board */
    struct fmcadc_dev *(*open)(const struct fmcadc_board_type *dev,
                               unsigned int dev_id,
                               unsigned int details);
    struct fmcadc_dev *(*open_by_lun)(char *devname, int lun);
    int (*close)(struct fmcadc_dev *dev);
    /* Handle acquisition */
    int (*start_acquisition)(struct fmcadc_dev *dev,
                             unsigned int flags,
                             struct timeval *timeout);
    int (*stop_acquisition)(struct fmcadc_dev *dev,
                            unsigned int flags);
    /* Handle configuration */
    int (*apply_config)(struct fmcadc_dev *dev,
                        unsigned int flags,
                        struct fmcadc_conf *conf);
    int (*retrieve_config)(struct fmcadc_dev *dev,
                           struct fmcadc_conf *conf);
    /* Handle buffers */
    int (*request_buffer)(struct fmcadc_dev *dev,
                          struct fmcadc_buffer *buf,
                          unsigned int flags,
                          struct timeval *timeout);
    int (*release_buffer)(struct fmcadc_dev *dev,
                          struct fmcadc_buffer *buf);
    char *(*strerror)(int errnum);
};
@end smallexample


Now, the duty of the @i{routing} is to parse the user-space request
and redirect it to the correct set of operations (implementation). For
example, if we are interacting with a ZIO driver, the library route our
request to the ZIO implementation of the ADC operations.

@c ==========================================================================
@node The ADC Library API
@section The ADC Library API

To avoid duplication and conseguent divergence of the documentation, the
description of the API details are explained in the library header. Please,
read the @file{lib/fmcadc-lib.h} to understand how to use the library

@c ==========================================================================
@node Demo tools for ADC library
@section Demo tools for ADC library

In the directory @file{libtools/} you can find two demo programs which use
the ADC library to interact with the driver. These programs are only demo;
the aim of this program is to provide an example to develop your own programs.

@c ==========================================================================
@node Simple Acquisition
@subsection Simple Acquisition

The simple acquisition demo program (@file{fald-simple-acq}) is a very simple
program that performs a simple acquisition. You can set some parameter to
customize your acquistion parameter.

@smallexample
fald-simple-acq [OPTIONS] 0x<DEVICE ID>

  <DEVICE>: hexadecimal string which represent the device identificator of an fmc-adc
  --pre|-p <value>: number of pre samples
  --post|-P <value>: number of post samples
  --nshots|-n <value>: number of trigger shots
  --delay|-d <value>: set the ticks delay of the trigger
  --threshold|-t <value>: set internal trigger threshold
  --channel|-c <value>: select the internal channel as trigger (0-based index)
  --external: set to external trigger. The default is the internal trigger.
  --negative-edge: set internal trigger polarity to negative edge. The default
                    is positive edge.
  --help|-h: show this help
@end smallexample

@c ==========================================================================
@node Retrieve Configuration
@subsection Retrieve Configuration

To retrieve a configuration from a device you can use the demo program
@file{fald-simple-get-conf}.

@smallexample
fald-simple-get-conf [OPTIONS] 0x<DEVICE ID>

  <DEVICE>: hexadecimal string which represent the device identificator of an fmc-adc
  --help|-h: show this help
@end smallexample

@c ##########################################################################
@node Troubleshooting
@chapter Troubleshooting

This chapters lists a few errors that may happen and how to deal with
them.

@menu
* ZIO Doesn't Compile::
* make modules_install misbehaves::
@end menu

@c ==========================================================================
@node ZIO Doesn't Compile
@section ZIO Doesn't Compile

Compilation of ZIO ma fail with error like:

@smallexample
   zio-ad788x.c:180: error: implicit declaration of function "spi_async_locked"
@end smallexample

This happens because the function wasn't there in your older kernel
version, and your system is configured to enable @code{CONFIG_SPI}.

To fix, please just remove the @i{zio-ad788x} line from
@code{drivers/Makefile}.

@c ==========================================================================
@node make modules_install misbehaves
@section make modules_install misbehaves

The command @i{sudo make modules_install} may place the modules in the wrong
directory or fail with an error like:

@smallexample
   make: *** /lib/modules/2.6.37+/build: No such file or directory.
@end smallexample

This happens when you compiled by setting @code{LINUX=} and your
@i{sudo} is not propagating the environment to its child processes.
In this case, you should run this command instead

@smallexample
   sudo make modules_install  LINUX=$LINUX
@end smallexample

@bye


