\input texinfo    @c -*-texinfo-*-
%
% fmc-adc-driver.in - main file for the documentation
%
%%%%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename fine-delay.info
@settitle fine-delay
@iftex
@afourpaper
@end iftex
@paragraphindent none
@comment %**end of header

@setchapternewpage off

@set update-month September 2012
@set release 0.8
@set tagname fmc-adc-k3.4-v0.8

@finalout

@titlepage
@title FMC ADC User's Manual
@subtitle @value{update-month} -- Release @value{release}
@subtitle FMC ADC 100M 14 b 4ch software manual
@author CERN BE-CO-HT / Federico Vaga / Alessandro Rubini
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@node Top
@top Introduction

This is the user manual of the driver for the @i{FMC ADC 100M 14b 4cha}
board developed on the @b{Open Hardware Repository}
@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha}}.


@menu
            
@end menu

@c ##########################################################################
@node Repositories and Releases
@chapter Repositories and Releases
This project is hosted on the Open Hardware repository at the
following link:

@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw}


Here a list of the resources that you can find on the project page.
@table @code 
 @item Document@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/documents}} contains the @t{.pdf} documentation for every official release.

@item File@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/files}} contains the @t{.tar.gz} file for every official release including the @t{.git} tree.

@item Repository@footnote{@uref{http://www.ohwr.org/projects/fmc-adc-100m14b4cha-sw/repository}} contains the git repository of the project
@end table

On the repository the official releases have a tag named @code{fmc-adc-sw-k#ver-v#num} where @i{#num} represent the release version of the driver and
@i{#ver} the kernel version (e.g @code{fmc-adc-sw-k3.4-v1.0} for the
release 1.0 on kernel 3.4). These tag are used in releted repository (@i{ZIO},
@i{spec-sw} and hardware repository).

@c ##########################################################################
@node Driver Features
@chapter Driver Features
This driver is based on the @i{ZIO} framework and the @i{spec-sw}
driver. It supports initial setup of the board; it allows users to
manually configure the board, to start and stop acquisitions, to force
trigger, to read latest time-stamps and to read acquired samples.

@c ##########################################################################
@node Installation
@chapter Installation
This driver depends on two other driver, as well as the Linux kernel.
Also, it must talk to a specific FPGA binary file running in the
carrier card.

@c ==========================================================================
@node Gateware Dependencies
@section Gateware Dependencies

This driver has been developed from the FPGA binary included in the package
as @file{binaries/fmc-adc.bin}.

The driver repository always include the last binary version used during
development. It can happend that the binary within this package become out
of dated when new binary is released.

@c ==========================================================================
@node Gateware Installation
@section Gateware Installation

To install the FPGA image in the target system, please follow the
instruction in the documentation of @i{spec-sw}. To summarize,
you'll need to place the @t{.bin} file in @file{/lib/firmware/}.
By default, the driver looks for @t{fmc/fmc-adc.bin}@footnote{the full
path will be @file{/lib/firmware/fmc/fmc-adc.bin}}. You
can find the copy of the last tested binary within the driver repository.
Anyway, you are free to use a different binary for the your
ADC and you can load it by specifying the module parameter @t{file}.

@c ==========================================================================
@node Software Dependencies
@section Software Dependencies

The Kernel version for the development was the 3.4, but this driver
is also available for kernel 2.6.32 and 2.6.24.

The driver is base on the ZIO framework available on the OpenHardware
Repository@footnote{@uref{http://www.ohwr.org/projects/zio}}. The version
being used during development is a development version and tested on Linux
kernel 3.4, then back-ported to Linux kernel version 2.6.32 and 2.6.24.

The driver is also based ont the @i{spec-sw} driver available on the
OpenHardware Repository@footnote{@uref{http://www.ohwr.org/projects/spec-sw}}.
This driver allow to handle FMC devices connected to a SPEC or a SVEC board.

@c ==========================================================================
@node Software Installation
@section Software Installation
First of all, please note that you need to define the following
environment variables to be able to compile this driver. All of them
are assumed to be already set when running the commands shown.

@table @code
@item LINUX
	The top-level directory of the Linux kernel you are compiling
        against. This document assumes it is already set.

@item ZIO
	The top-level directory of the ZIO repository checkout.

@item SPEC_SW
	The top-level directory of the @i{spec-sw} repository checkout.

@end table

To install ZIO you should download it and install the tag (or branch)
called @i{fmc-adc-sw-k#ver-v#num} according the version that you need.
In the following example it is shown the installation of the release
1.0 of this driver on kernel 2.6.32:

The commands here are reported without prompt for easy cut-and-paste.
@smallexample
test -d zio/.git || git clone git://ohwr.org/misc/zio.git
cd zio
export ZIO=$(/bin/pwd)
git checkout -b fmc-adc fmc-adc-sw-k2.6.32-v1.0
make
sudo make modules_install
@end smallexample

The procedure for spec-sw is similar:

@smallexample
test -d spec-sw/.git || \
git clone git://ohwr.org/fmc-projects/spec/spec-sw.git
cd spec-sw
export SPEC_SW=$(/bin/pwd)
git checkout -b fine-delay fine-delay-sw-v1.1
cd kernel
make
sudo make modules_install
@end smallexample

Now you can compile this driver with @code{make}. At this point all
the software modules are ready to be loaded.
/hyper
@c ==========================================================================
@node Module Parameters
@section Module Parameters
The driver accepts a few load-time parameters for configuration. You
can pass them to insmod directly, or write them in @file{/etc/modules.conf}
or the proper file in @file{/etc/modutils/} .


The following parameters are used:
@table @code
 @item file=/path/to/binary.bin
  The binary file to use to reprogram the FPGA. The default value for this
  parameter is @t{fmc/fmc-adc-bin} as seen in @ref{Gateware Installation}.
  The path to binary is the relative path from @file{/lib/firmware}
 @item enable_test_data=1
  This is for testing purpose. This option enable the testing data, so the ADC
  doesn't store samples, but fill the memory with sequential numbers.
@end table

@c ##########################################################################
@node Source Code Conventions
@chapter Source Code Conventions
This is a random list of conventions used in this package

@itemize @bullet
 @item All the internal symbols used in the whole driver begin with the prefix @t{fa_}. The prefix mean: @i{Fmc Adc}.
 @item All internal symbols in the zio driver begin with @t{zfad_}. The prefix mean: @i{Zio Fmc Adc Driver}.

 @item All internal symbols in the zio trigger begin with @t{zfat_}. The prefix mean: @i{Zio Fmc Adc Trigger}.
 
 @item The @file{tools/} directory includes standalone tools that access ZIO
       directly. Their name begins with @file{fau-} that mean: @i{Fmc Adc User}.
       There is also a non ZIO tool to generate pulses on the parallel port,
       so it has a different name pattern.

@end itemize

@c ##########################################################################
@node Device Configuration
@chapter Device Configuration

The driver is designed as a ZIO driver that offers 4 input channels. Since
the device store only interleaved data, the ZIO framework will create a
fifth channel which represent the interleaved acquisition.

The reader of this chapter is expected to be confident with basic ZIO
concepts, available in ZIO documentation@footnote{@uref{http://www.ohwr.org/projects/zio/documents}}.

@c ==========================================================================
@node The ZIO Device Structure
@section The ZIO Device Structure

The device has 1 cset with 4+1 channels. Channels from 0 to 3
represent che physical channels 1 to 4. The 5th channel
@i{chani} represent a virtual channel created automatically by the
ZIO framework; this channel represent the interleave acquisition on
the cset.

@float
@center @image{img/fmc-adc-hierarchy, 7cm,,FMC ADC ZIO hierarchy, pdf}
@end float

The ADC registers can be accessed in the proper @i{sysfs} directory. For a
card in slot 0 of bus 1 (like shown above), the directory is 
@i{/sys/bus/zio/devices/fmc-adc-0100}.

The overall device (@i{fmc-adc}) has not any particular capabilities because
the main features are handled by @i{cset0} and @i{trigger}. So, there are
not any device-wide attribute, there are only the ZIO's default attributes.

@smallexample
corinno-test:~# ls -Ff /sys/bus/zio/devices/fmc-adc-0100/
./  ../  name  cset0/  power/  driver@  enable  subsystem@  uevent 
@end smallexample

@c ==========================================================================
@node The Channel Set
@section The Channel Set

The ADC has 1 Channel Set named @file{cset0}. It has attributes to handle the
ADC state machine, the acquisition and the time stamp.

@smallexample
corinno-test:~# ls -Ff /sys/bus/zio/devices/fmc-adc-0100/
./  ../  name  cset0/  power/  driver@  enable  subsystem@  uevent
corinno-test:~# ls -Ff /sys/bus/zio/devices/fmc-adc-0100/cset0/            
./      chan3/           rst-ch-offset     tstamp-acq-end-s  tstamp-acq-str-s   
../     chani/           enable            tstamp-acq-end-t  tstamp-acq-str-t   
name    power/           sample-decimation tstamp-acq-stp-b  uevent             
chan0/  fsm-command      fsm-state         tstamp-acq-stp-s  current_buffer     
chan1/  current_trigger  trigger/          tstamp-acq-stp-t                     
chan2/  resolution-bits  tstamp-acq-end-b  tstamp-acq-str-b  
@end smallexample

The @b{resolution-bits} attribute is read-only and it returns the
number of bits of the ADC:

@smallexample
corinno-test:~# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/resolution-bits
14
@end smallexample

The @b{rst-ch-offset} attribute is write-only. When you write on it, the
driver reset the offset of all channels. 

@smallexample
corinno-test:~# echo 0 > /sys/bus/zio/devices/fmc-adc-0100/cset0/rst-ch-offset
@end smallexample

@c --------------------------------------------------------------------------
@node Sample Decimation
@subsection Sample Decimation

The ADC always acquire at 100MSamples/s and this value cannot be changed. If
you need less samples you can use the @i{sample-decimation} attribute.

The @b{sample-decimation} attribute is read/write. It configures the number
of sample to drop. You can use value between 1 and 65535.

@smallexample
corinno-test:~# echo 4 > /sys/bus/zio/devices/fmc-adc-0100/cset0/sample-decimation
@end smallexample

The value to write on decimation mean the number of sample to acquire for
each valide samples, for example:

@smallexample
o -> valid sample 
x -> dropped sample

decimation = 1
oooooooooooooooooooo
decimation = 2
oxoxoxoxoxoxoxoxoxox
decimation = 3
oxxoxxoxxoxxoxxoxxox
decimation = 4
oxxxoxxxoxxxoxxxoxxx
decimation = 5
oxxxxoxxxxoxxxxoxxxx
[...]
@end smallexample

@c ---------------------------------------------------------------------------
@node The State Machine
@subsection The State Machine

The acquisition steps are implemented with a @b{state machine}. The driver
exports to the user-space two attributes to handle it: @i{fsm-state} and
@i{fsm-command}.

The @b{fsm-state} attribute is read-only and it returns the code of the
current state of the state machine. In the following example, the state
machine is in the status @i{idle}

@smallexample
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/fsm-state
1
@end smallexample

The @b{fsm-command} attribute is write-only. It is used to write a command
for the state machine. The command available are @i{start} and @i{stop}. The
correspondent values for these commands are, respectively, 1 and 2.


The @i{start} command is used to start the state machine, so to start an
acquisition. You cannot acquire if you don't start the state machine. To
start the state machine you can use the following command:

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/fsm-command
@end smallexample

If the state machine started, the green LED @i{ACQ} on the front panel of the
ADC turns on. 

If you want to abort the current acquisition you must send the
@i{stop} command to the state machine.

@smallexample
# echo 2 > /sys/bus/zio/devices/fmc-adc-0100/cset0/fsm-command
@end smallexample

When the state machine is stopped, the @i{ACQ} LED turns off. When you send
a @i{stop} command, the driver flush the memory, so all samples acquired are
lost.


Doing the @i{start} command when the state machine is already started do a
restart of the state machine and it flush the memory. This is the same
of following sequence of commands @i{start},@i{stop} and @i{start}.


To acquire data you must start the state machine, if you do not start the
state machine, you cannot acquire data. When an acquisition is completed the
state machine automatically send a @i{stop} command, so you must start the
state machine again for the next acquisition. An acquisition is considered
completed when all stamples, from all shots, are acquired.


The ADC mark with a timestamp all these events: state machine start, state
machine stop and acquisition end. The device split each timestamp in 3
attributes named: second (s), ticks (t) and bins (b). For example, to read
the entire timestamp of the state machin start event you should do:

@smallexample
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/tstamp-acq-str-s
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/tstamp-acq-str-t
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/tstamp-acq-str-b
@end smallexample

Seconds represents the number of second since the epoch; ticks is the
number of clocks at 125Mhz, the value is between 0 and 125000000 and it
increments seconds when it overflow. At the moment, the bins register is
unused.

@c ==========================================================================
@node The Channels
@section The Channels

The ADC has 4 input channels. Each channel has two configurable attributes:
@i{offset} and @i{vref-src}, and one attribute with the last acquired sample
@i{current-value}.

@smallexample
# ls -fF /sys/bus/zio/devices/fmc-adc-0100/cset0/chan0/
./   name    vref-src       buffer/  uevent
../  power/  current-value  enable   offset
@end smallexample

The @b{offset} attribute is read/write. It allows to configure the offset of
the signal on the channel. When you write a value to this attribute, the driver
apply your value to a DAC which apply an offset to the input signal.

@smallexample
# echo 50 > /sys/bus/zio/devices/fmc-adc-0100/cset0/chan2/offset
@end smallexample

The @b{vref-src} attribute is read/write. It allow you to change the Volt
reference of the ADC; the attribute accepts only 4 value: @i{0} (open range),
@i{35} ([-100mV; +100mV), @i{17} ([-1V; +1V]), @i{69} ([-10V; +10V]).

@smallexample
# echo 17 > /sys/bus/zio/devices/fmc-adc-0100/cset0/chan2/vref-src
@end smallexample

The @b{current-value} attribute is read only. It returns the last converted
value on the channel.

@smallexample
# cat /sys/bus/zio/devices/fmc-adc-0100/cset0/chan0/current-value 
32860
@end smallexample

@c ==========================================================================
@node The Trigger
@section The Trigger

The ADC has its own @i{zio_trigger_type} and it can not work with any other
ZIO's trigger. The ADC trigger is named @b{fmc-adc-trg}. We advise you
against replacing the trigger with another one. The sysfs directory of this
trigger is the following:

@smallexample
# ls -fF /sys/bus/zio/devices/fmc-adc-0100/cset0/trigger/
./           external          delay      sw-trg-enable  sw-trg-fire
../          tstamp-trg-lst-b  power/     enable         post-samples
name         tstamp-trg-lst-s  polarity   uevent         int-threshold
int-channel  tstamp-trg-lst-t  re-enable  pre-samples
@end smallexample

On the ADC there are two kind of trigger: hardware and software.

@c ---------------------------------------------------------------------------
@node Hardware Trigger
@subsection Hardware Trigger

The @b{hardware trigger} is moved by the hardware, depending on the status of
the input signals (@i{internal trigger}), or on impulse from an external
source (@i{external trigger}).

The ZIO's default attribute @b{enable} is directly connected to the enable
of the hardware trigger on device. So, if you write 1 you enable the hardware
trigger, if you write 0 you disable the hardware trigger.

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/trigger/enable
@end smallexample

The attribute @b{external} can be used to select the @i{internal trigger}
or the @i{external trigger}. You must write 1 to select the external trigger,
0 to select the internal trigger.

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/trigger/external
@end smallexample

With the attribute @b{polarity} you can configure if the trigger fire on a
positive edge/slope or on a negative edge/slope. To configure positive
edge/slope you must write 0 on this attribute, otherwise 1 for a negative
edge/slope.

@smallexample
# echo 1 > /sys/bus/zio/devices/fmc-adc-0100/cset0/trigger/polarity
@end smallexample
 

@c ---------------------------------------------------------------------------
@node Internal Trigger
@subsubsection Internal Trigger

The @b{internal trigger} is an @i{hardware trigger} and its fire depend on the
the input signal. 
You can select which of the four channels is the trigger source and then
configure a threshold. When the signal goes above/under@footnote{it depends
on the attribute @i{polarity}} the
threshold, the trigger fire.

To choose a channel as trigger source you must use the @b{int-channel}
attribute. You can select one of the input channel by writing its index
number on the attribute [0; 3]

The attribute @b{int-threshold} is read/write and can be used to select
the signal threshold.

@c ---------------------------------------------------------------------------
@node External Trigger
@subsubsection External Trigger

The @b{external trigger} is an @i{hardware trigger} and its fire depend on
an external source of impulse. When the pulse arrive, the trigger fires.

@c ---------------------------------------------------------------------------
@node Software Trigger
@subsection Software Trigger

The software trigger should be used only for debug purpose. You can enable
it by writing 1 on the attribute @b{sw-trg-enable}, 0 to disable it. To make
this trigger fire, you must write in the write-only attribute @b{sw-trg-fire}.

@c ==========================================================================
@node The Buffer
@section The Buffer

The ADC can use both @i{zio-buf-kmalloc} and @i{zio-buf-vmalloc} to store
the samples. It is not necesarry to develop a dedicated buffer for this device.
By default the driver is configured to use the @i{zio-buf-vmalloc} buffer.


If you want to change the buffer, you can use the @code{current_buffer}
attribute within the @code{cset0} directory. As explained in the ZIO manual,
this is a default attribute of the ZIO framework. It allows the user to
dinamically change the buffer to use. If you want to use the @i{kmalloc}
buffer you must write:

@smallexample
# echo kmalloc > /sys/bus/zio/devices/fmc-adc-0100/cset0/current_buffer
@end smallexample

To restore the @i{vmalloc} buffer:

@smallexample
# echo vmalloc > /sys/bus/zio/devices/fmc-adc-0100/cset0/current_buffer
@end smallexample

@c ==========================================================================
@node Attributes
@section Attributes

Here the list of all the ZIO's attributes within this driver. Plese note
that ZIO framework can handle only 32bit unsigned integer.

     @multitable @columnfractions .10 .25 .2 .1 .2 .30
     @headitem Target @tab Name @tab Permission @tab Default @tab Accepted @tab Comment 
     @c Cset
     @item Cset @tab @code{enable} @tab rw @tab 1 @tab [0;1]
     @item Cset @tab @code{resolution-bits} @tab ro @tab 14 @tab -
     @item Cset @tab @code{fsm-command} @tab wo @tab 2 @tab [1;2]
     @item Cset @tab @code{fsm-state} @tab ro @tab - @tab -
     @item Cset @tab @code{sample-decimation} @tab rw @tab 1 @tab [1;655353]
     @item Cset @tab @code{rst-ch-offset} @tab wo @tab 0 @tab any
     @item Cset @tab @code{tstamp-acq-str-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-str-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-str-b} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-stp-b} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-acq-end-b} @tab ro @tab - @tab -
     @c Channel
     @item Cset @tab @code{offset} @tab rw @tab 0 @tab [0; 65535] @tab [-Vref; +Vref]
     @item Cset @tab @code{vref-src} @tab rw @tab 17 @tab [0, 17, 35, 69]
     @c Trigger
     @item Trigger @tab @code{enable} @tab rw @tab 1 @tab [0;1]
     @item Trigger @tab @code{external} @tab rw @tab 1 @tab [0;1]
     @item Trigger @tab @code{polarity} @tab rw @tab 0 @tab [0;1]
     @item Trigger @tab @code{int-channel} @tab rw @tab 0 @tab [0;3]
     @item Trigger @tab @code{int-threshold} @tab rw @tab 0 @tab [0;65535] @tab Complement 2
     @item Trigger @tab @code{sw-trg-enable} @tab rw @tab 0 @tab [0;1]
     @item Trigger @tab @code{sw-trg-fire} @tab wo @tab 0 @tab any
     @item Cset @tab @code{tstamp-trg-s} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-trg-t} @tab ro @tab - @tab -
     @item Cset @tab @code{tstamp-trg-b} @tab ro @tab - @tab -
     @end multitable

@c ==========================================================================
@node Reading Data with Char Devices
@chapter Reading Data with Char Devices
To read data from user-space you can use the ZIO char device interface
which export 2 char device for each channel (as documented in
ZIO documentation). The ADC acquire only interleaved samples, so the char
device interface creates only the char device for the interleaved acquisition.

@smallexample
# ls -l /dev/zio/
total 0
crw------- 1 root root 250, 8 Aug 23 22:21 fmc-adc-0100-0-i-ctrl
crw------- 1 root root 250, 9 Aug 23 22:21 fmc-adc-0100-0-i-data
@end smallexample

The actual pathnames depend on the version of @i{udev}, and the support
library tries both names (the new one shown above, and the older one,
without a @code{zio} subdirectory).
Also, please note that a still-newer version of @i{udev} obeys device
permissions, so you'll have read-only and write-only device files.


If more than one board is probed for, you'll have two or more similar
sets of devices, differing in the @i{dev_id} field, i.e. the
@code{0100}. The @i{dev_id} field is built using the PCI bus
and the @i{devfn} octet; the example above refers to slot 0 of bus 1.


The ADC doesn't allow to read data from a specific channel; the ADC
allow the driver to read only an interleaved block of samples.
Neither the ZIO core nor this driver split interleaved data into
4 different buffer; so, also the driver will return to user-space a
block of interleaved samples. To read this interleaved block you
can read directly the interleaved data char device @i{fmc-adc-0100-0-i-data}
using simple program like @i{hexdump}@footnote{man hexdump if you do not
know this program}:

@smallexample
# hexdump -n 8 -e '"" 1/2 "%x\n"' /dev/zio/fmc-adc-0100-0-i-data
fffc
e474
8034
8084
@end smallexample


The FMC ADC interleave always all channels, you cannot select which channel
acquire. So your acquisitions will have this format:


@float
@center @image{img/interleaved, 7cm,,ADC interleaved data,pdf}
@end float


It is suggested to read the ZIO documentation to understand how to read data
from the ZIO char device interface and the mechanism of control char device
and data char device. You can use the @b{zio-dump} tool from
the ZIO package to acquire data and understand the mechanism behind this 
interface.


@c ==========================================================================
@node Tools
@chapter Tools

The FMC ADC driver is provided with three tools: @i{fau-trg-config}, @i{fau-acq-time} and @i{parport-burst}.

@c ==========================================================================
@node Trigger Configuration
@section Trigger Configuration

You can use the tool @b{fau-trg-config} to configure the FMC ADC trigger. The
tools has many command line parameter that you can use to configure every
register exporter by the driver. You can read a simple description of the
program from the program's help.

@smallexample
$ ./fau-trg-config --help

fau-trg-config [OPTIONS] <DEVICE>

  <DEVICE>: ZIO name of the device to use
  --pre|-p <value>: number of pre samples
  --post|-P <value>: number of pre samples
  --re-enable|-r <value>: number of trigger shots
  --delay|-d <value>: set the ticks delay of the trigger
  --threshold|-t <value>: set internal trigger threshold
  --channel|-c <value>: select the internal channel as trigger
  --external: set to external trigger. The default is the internal trigger.
  --negative-edge: set internal trigger polarity to negative edge. The default
                    is positive edge.
  --enable-sw-trg: enable the software trigger. By default is disabled.
  --disable-hw-trg: disable the hardware trigger. By default is enabled
  --force: force all attribute to the program default
  --help|-h: show this help

NOTE: The software trigger works only if also hardware trigger is enabled
@end smallexample

The tool gets the configuration values from the user and it writes these values
in the correspondent sysfs attributes exported by the driver. For example, if
you want to configure the trigger to fire with an external pulse and to acquire
3 shots of 10 pre-samples and 100 post-samples, you must write:

@smallexample
# ./fau-trg-config --external --pre 10 --post 100 --re-enable 2 fmc-adc-0100
@end smallexample

The trigger is always active the first time, then you configure it to auto
re-enable other 2 times; so you acquire 3 shots.

@c ==========================================================================
@node Acquisition Time
@section Acquisition Time

You can use the tool @b{fau-acq-time} to get the time spent during the
acquisition.  You can read a simple description of the
program from the program's help.

@smallexample
# ./fau-acq-time 

fau-acq-time [OPTIONS] <DEVICE>

  <DEVICE>: ZIO name of the device to use
  --last|-l : time between the last trigger and the acquisition end
  --full|-f : time between the acquisition start and the acquisition end
  --help|-h : show this help

@end smallexample

The program can return two kind of acquisition time. The first acquisition
time (@code{--last}) is the time between the last trigger event and the
acquisition end event, so the time spent during the last shot. The second
acquisition time (@code{--full}) is the time between the acquisition start
event and the acquisition end event, so the whole time spent to wait all
trigger fires (multi shots) and the time to acquire all samples.

@c ==========================================================================
@node Parallel Port Burst
@section Parallel Port Burst
If you have a Parallel Port you can use it to generate bursts of pulses
with a software program. This is usefull to test external trigger; you can
connect the parallel port to the external trigger of the FMC ADC and
generate your trigger fire from an external source.

The program @b{parport-burst}@footnote{This tool is also part
of the @i{fine-delay} tools.}, part of this package, generates a
burst according to three command line parameters: the I/O port of
the data byte of the parallel port, the repeat count and the duration
of each period. This example makes 1000 pulses of 100 usec each,
using the physical address of my parallel port (if yours is part
of the motherboard, the address is @code{378}):

@example
   ./parport-burst dd00 1000 100
@end example

@c ##########################################################################
@node Troubleshooting
@chapter Troubleshooting

This chapters lists a few errors that may happen and how to deal with
them.

@menu
* ZIO Doesn't Compile::         
* make modules_install misbehaves::            
@end menu

@c ==========================================================================
@node ZIO Doesn't Compile
@section ZIO Doesn't Compile

Compilation of ZIO ma fail with error like:

@smallexample
   zio-ad788x.c:180: error: implicit declaration of function "spi_async_locked"
@end smallexample

This happens because the function wasn't there in your older kernel
version, and your system is configured to enable @code{CONFIG_SPI}.

To fix, please just remove the @i{zio-ad788x} line from
@code{drivers/Makefile}.

@c ==========================================================================
@node make modules_install misbehaves
@section make modules_install misbehaves

The command @i{sudo make modules_install} may place the modules in the wrong
directory or fail with an error like:

@smallexample
   make: *** /lib/modules/2.6.37+/build: No such file or directory.
@end smallexample

This happens when you compiled by setting @code{LINUX=} and your
@i{sudo} is not propagating the environment to its child processes.
In this case, you should run this command instead

@smallexample
   sudo make modules_install  LINUX=$LINUX
@end smallexample

@bye


